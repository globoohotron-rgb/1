#!/usr/bin/env python3
import argparse, csv, json, sys, re
from pathlib import Path
from datetime import datetime, timedelta

ROOT = Path(__file__).resolve().parent.parent  # корінь репо

def _read_csv(p: Path):
    with p.open(newline='', encoding='utf-8') as f:
        return list(csv.DictReader(f))

def _ensure_placeholder_targets(p: Path):
    p.parent.mkdir(parents=True, exist_ok=True)
    with p.open('w', newline='', encoding='utf-8') as f:
        f.write("symbol,weight\nAAA,0.5\nBBB,-0.5\n")

def _ensure_placeholder_returns(p: Path):
    p.parent.mkdir(parents=True, exist_ok=True)
    with p.open('w', newline='', encoding='utf-8') as f:
        f.write("symbol,r\nAAA,0.01\nBBB,-0.005\n")

def _guess_ci(keys, candidates):
    kl = {k.lower(): k for k in keys}
    for c in candidates:
        if c.lower() in kl:
            return kl[c.lower()]
    return None

_num = re.compile(r"^[\s+-]?\d+(\.\d+)?([eE][+-]?\d+)?\s*$")

def _numeric_score(rows, key):
    ok = 0
    for r in rows:
        v = r.get(key, "")
        if isinstance(v, (int, float)):
            ok += 1
            continue
        if isinstance(v, str) and _num.match(v):
            try:
                float(v); ok += 1
            except Exception:
                pass
    return ok

def _pick_symbol_key(keys):
    return _guess_ci(
        keys,
        ("symbol","ticker","asset","secid","code","id","isin","ric","name")
    ) or list(keys)[0]

def _pick_weight_key(rows):
    keys = rows[0].keys()
    k = _guess_ci(keys, ("w_final","weight","w","target_weight","w_pre","weight_total"))
    if k: return k
    # Обираємо найбільш числову колонку
    best = max(keys, key=lambda key: _numeric_score(rows, key))
    return best

def _pick_return_key(rows):
    keys = rows[0].keys()
    k = _guess_ci(keys, ("r","ret","return","r1d","log_ret","r_d1","gross_return"))
    if k: return k
    best = max(keys, key=lambda key: _numeric_score(rows, key))
    return best

def cmd_perf(date_str: str) -> int:
    try:
        d = datetime.strptime(date_str, '%Y-%m-%d').date()
    except ValueError:
        print("ERR: --date must be YYYY-MM-DD", file=sys.stderr)
        return 2
    d1 = d + timedelta(days=1)
    targets_path = ROOT / "targets" / f"{d.isoformat()}.csv"
    returns_path = ROOT / "returns" / f"{d1.isoformat()}.csv"

    if not targets_path.exists():
        _ensure_placeholder_targets(targets_path)
        print(f"NOTE: created placeholder {targets_path}", file=sys.stderr)
    if not returns_path.exists():
        _ensure_placeholder_returns(returns_path)
        print(f"NOTE: created placeholder {returns_path}", file=sys.stderr)

    t_rows = _read_csv(targets_path)
    r_rows = _read_csv(returns_path)
    if not t_rows or not r_rows:
        print("ERR: empty CSV(s)", file=sys.stderr)
        return 1

    t_sym = _pick_symbol_key(t_rows[0].keys())
    w_col = _pick_weight_key(t_rows)
    r_sym = _pick_symbol_key(r_rows[0].keys())
    r_col = _pick_return_key(r_rows)

    # карта доходностей
    rmap = {}
    for row in r_rows:
        try:
            rmap[row[r_sym]] = float(row[r_col])
        except Exception:
            continue

    gross = 0.0
    matched = 0
    for row in t_rows:
        try:
            s = row[t_sym]
            w = float(row[w_col])
        except Exception:
            continue
        r = rmap.get(s)
        if r is None:
            continue
        gross += w * r
        matched += 1

    out = {'date': d.isoformat(), 'gross_return': gross}
    out_path = ROOT / "performance" / f"{d.isoformat()}.json"
    out_path.parent.mkdir(parents=True, exist_ok=True)
    with out_path.open('w', encoding='utf-8') as f:
        json.dump(out, f, ensure_ascii=False, separators=(',', ':'))

    print(f" Perf {d.isoformat()}: r={gross:.6f}")
    return 0

def main():
    p = argparse.ArgumentParser(prog='ats')
    sub = p.add_subparsers(dest='cmd', required=True)
    p_perf = sub.add_parser('perf', help='compute daily gross return')
    p_perf.add_argument('--date', required=True, help='YYYY-MM-DD (targets date)')
    args = p.parse_args()
    if args.cmd == 'perf':
        sys.exit(cmd_perf(args.date))

if __name__ == '__main__':
    main()
